<!DOCTYPE HTML>

<html lang='en'>
	<head>
		<title>怎么才叫熟悉http协议? &middot; Yeqown</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		
		
		
		<link rel="stylesheet" href="/assets/css/main.min.css">
		
		
		<link rel="shortcut icon" href="favicon.ico">
		
		
		<noscript><link rel="stylesheet" href='/assets/css/noscript.css' /></noscript>
		<link rel="stylesheet" href="/highlight/styles/monokai-sublime.css">
		
		<script src="/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body lang='en' class="is-preload">

		
			<div id="wrapper">

                
<header id="header">
    <a href='/' class="logo">Yeqown</a>
</header>

                

<nav id="nav">
    <ul class="links">
        <li class="active"><a href='/'>Yeqown</a></li>
        
        <li><a href='/#footer'>Contact</a></li>
        
        
    </ul>
    
    <ul class="icons">
        
        <li><a href="https://twitter.com/yeqown" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
        
        
        
        
        
        <li><a href="https://github.com/yeqown" class="icon fa-github"><span class="label">GitHub</span></a></li>
        
        
        
        
        
    </ul>
    
</nav>


				
					<div id="main">

						
                        <section class="post">
                            <header class="major">
                                
                                <span class="date">June 28, 2018</span>
                                
                                <h1>怎么才叫熟悉http协议?</h1>
                                <p>“熟悉http协议”，肯定很多IT小伙伴都在招聘岗位上看得到过，但是怎么才叫熟悉http协议呢？抽空梳理了一下，也算是对这一部分知识的笔记吧！</p>
                            </header>
                            
                            <p>“熟悉http协议”，肯定很多IT小伙伴都在招聘岗位上看得到过，但是怎么才叫熟悉http协议呢？抽空梳理了一下，也算是对这一部分知识的笔记吧！</p>
<p>可能对于大部分人来说，网络web编程就是使用一些第三方库来进行请求和响应的处理，再多说一点就是这个<code>URI</code>要使用<code>POST</code>方法，对于携带的数据需要处理成为<code>formdata</code>。</p>
<!-- more -->
<h2 id="基础知识">基础知识</h2>
<p><strong>Q1: HTTP协议是什么？用来干什么？</strong></p>
<blockquote>
<p>HTTP协议是基于TCP/IP协议的应用层协议，主要规定了客户端和服务端之间的通信格式。主要作用也就是传输数据（HTML，图片，文件，查询结果）。</p>
</blockquote>
<h3 id="网络分层">#网络分层</h3>
<blockquote>
<p>互联网的实现分成了几层，如何分层有不同的模型（七层，五层，四层），这里按五层模型来解释：</p>
</blockquote>
<p>（靠近用户）应用层 &lt; 传输层 &lt; 网络层 &lt; 链接层 &lt; 物理层（靠近硬件）</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>作用</th>
<th>拥有协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理层</td>
<td>传送电信号0 1</td>
<td>无</td>
</tr>
<tr>
<td>数据链路层</td>
<td>定义数据包;网卡MAC地址;广播的发送方式;</td>
<td>Ethernet 802.3; Token Ring 802.5</td>
</tr>
<tr>
<td>网络层</td>
<td>引进了IP地址，用于区分不同的计算机是否属于同一网络</td>
<td>IP; ARP; RARP</td>
</tr>
<tr>
<td>传输层</td>
<td>建立端口到端口的通信，实现程序时间的交流，也就是socket</td>
<td>TCP; UDP</td>
</tr>
<tr>
<td>应用层</td>
<td>约定应用程序的数据格式</td>
<td>HTTP; FTP; DNS</td>
</tr>
</tbody>
</table>
<p><em>每一层级，都是解决问题而诞生的，也就是他们各自作用对应的问题，推荐参考资料中的“互联网协议入门”。</em></p>
<h3 id="http通信流程">#HTTP通信流程</h3>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/2/1628583763cf81ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http通信传输流"></p>
<h3 id="拓展--三次握手和四次挥手">#拓展&ndash;三次握手和四次挥手</h3>
<p>经常在其他地方看到这些，一直不知道了解这部分有什么用，但是<a href="https://en.wikipedia.org/wiki/SYN_flood"><code>syn Flood</code></a>攻击，恰恰是利用了TCP三次握手中的环节。利用假IP伪造<code>SYN</code>请求，服务端会多次尝试发送<code>SYN-ACK</code>给客户端，但是IP并不存在也就无法成功建立连接。在一定时间内伪造大量这种请求，会导致服务器资源耗尽无法为正常的连接服务。(注：服务器SYN连接数量有限制，SYN-ACK超时重传机制)</p>
<p>三次握手流程：</p>
<blockquote>
<ol>
<li>The client requests a connection by sending a SYN (synchronize) message to the server.</li>
<li>The server acknowledges this request by sending SYN-ACK back to the client.</li>
<li>The client responds with an ACK, and the connection is established.</li>
</ol>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Tcp_normal.svg/220px-Tcp_normal.svg.png" alt="TCP three-way handshake"></p>
<p>四次挥手流程：</p>
<blockquote>
<p>When an endpoint wishes to stop its half of the connection, it transmits a FIN packet. which the other end acknowledges with an ACK. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint. After the side that sent the first FIN has responded with the final ACK, it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Deconnection_TCP.png/220px-Deconnection_TCP.png" alt="TCP close connection"></p>
<h2 id="http报文">HTTP报文</h2>
<blockquote>
<p>HTTP报文是由一行一行的简单字符串组成的，HTTP报文都是纯文本。</p>
</blockquote>
<p>HTTP报文包括三个部分：起始行；头部字段；主体数据。其中头部是非常重要的部分，会单独成章。</p>
<p><img src="/images/http_request_content.png" alt="Request">
举例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">GET / HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Upgrade-Insecure-Requests: <span style="color:#ae81ff">1</span>
User-Agent: Mozilla/5.0 <span style="color:#f92672">(</span>Macintosh; Intel Mac OS X 10_11_6<span style="color:#f92672">)</span> AppleWebKit/537.36 <span style="color:#f92672">(</span>KHTML, like Gecko<span style="color:#f92672">)</span> Chrome/54.0.2840.71 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q<span style="color:#f92672">=</span>0.9,image/webp,*/*;q<span style="color:#f92672">=</span>0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q<span style="color:#f92672">=</span>0.8,en;q<span style="color:#f92672">=</span>0.6
Cookie: BAIDUID<span style="color:#f92672">=</span>4082549DEE5E64678FC46642E185D98C:FG<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p><img src="/images/http_response_content.png" alt="Response">
举例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">HTTP/1.1 <span style="color:#ae81ff">200</span> OK
Server: bfe/1.0.8.18
Date: Thu, <span style="color:#ae81ff">03</span> Nov <span style="color:#ae81ff">2016</span> 08:30:43 GMT
Content-Type: text/html
Content-Length: <span style="color:#ae81ff">277</span>
Last-Modified: Mon, <span style="color:#ae81ff">13</span> Jun <span style="color:#ae81ff">2016</span> 02:50:03 GMT
Connection: Keep-Alive
ETag: <span style="color:#e6db74">&#34;575e1f5b-115&#34;</span>
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Pragma: no-cache
Accept-Ranges: bytes
</code></pre></div><h3 id="状态码">#状态码</h3>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<p>1xx：指示信息 （表示请求已接收，继续处理）
2xx：成功 （表示请求已被成功接收、理解、接受）
3xx：重定向 （要完成请求必须进行更进一步的操作）
4xx：客户端错误 （请求有语法错误或请求无法实现）
5xx：服务器端错误 （服务器未能实现合法的请求）</p>
<p>这里我觉得很有必要说一下的：3xx。最近开发的时候遇到一个情况：</p>
<p>从页面上post跳转到第三方页面，完成后对方会通过POST携带数据的方式返回到我们的页面。在前后端分离的开发模式下，暂时没有想到前端自行解决的方法，因此我们通过服务端来处理这个POST回调接受数据，再通过重定向的方式，跳回到我们自己的页面（只需要将处理结果：成功或者失败，通过url参数传给前端）。</p>
<p>重定向的时候，随便选择了一个307（Temporary Redirect），然后返回页面的时候还是会提示：“501 Not Implemented， 意思就是：页面不支持POST请求”。解决办法是要把这个POST转成GET咯，怎么转呢？如下：</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Text</th>
<th>Method handling</th>
<th>Typical use case</th>
</tr>
</thead>
<tbody>
<tr>
<td>302</td>
<td>Found</td>
<td>GET methods unchanged.Others may or may not be changed to GET</td>
<td>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don&rsquo;t update their links.</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>GET methods unchanged.Others changed to GET (body lost).</td>
<td>Used to redirect after a PUT or a POST to prevent a refresh of the page that would re-trigger the operation.</td>
</tr>
<tr>
<td>307</td>
<td>Temporary</td>
<td>Redirect Method and body not changed.</td>
<td>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don&rsquo;t update their links. Better than 302 when non-GET links/operations are available on the site.</td>
</tr>
</tbody>
</table>
<p>我们需要的就是303了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Redirect</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">url</span>, <span style="color:#ae81ff">303</span>) <span style="color:#75715e">// 把r(POST)重定向到url(GET)
</span></code></pre></div><h2 id="http头部">HTTP头部</h2>
<p>这部分也就是常说的Header，在HTTP协议中头部主要作用为：传递额外信息。在HTTP中头部常见分类有：请求头部/响应头部/通用头部/实体头部。
这里也不细说每个请求头的作用了（反正都是搜集别人的资料～，可以参见<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN HTTP Headers</a>），就放几个可能会有帮助的：</p>
<h3 id="set-cookie-response">#Set-Cookie [Response]</h3>
<p>发送cookies到客户端，客户端请求的时候带上Cookie发送给服务端，可以完成一些验证。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt; 
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Expires<span style="color:#f92672">=</span>&lt;date&gt;
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Max-Age<span style="color:#f92672">=</span>&lt;non-zero-digit&gt;
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Domain<span style="color:#f92672">=</span>&lt;domain-value&gt;
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Path<span style="color:#f92672">=</span>&lt;path-value&gt;
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Secure
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; HttpOnly

Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; SameSite<span style="color:#f92672">=</span>Strict
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; SameSite<span style="color:#f92672">=</span>Lax

// Multiple directives are also possible, <span style="color:#66d9ef">for</span> example:
Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Domain<span style="color:#f92672">=</span>&lt;domain-value&gt;; Secure; HttpOnly
</code></pre></div><h3 id="access-control-allow-origin-repsonse">#Access-Control-Allow-Origin [Repsonse]</h3>
<p>允许哪个域可以访问你的资源</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: &lt;origin&gt;
</code></pre></div><h3 id="access-control-allow-credentials-response">#Access-Control-Allow-Credentials [Response]</h3>
<p>跨域请求必设置</p>
<blockquote>
<p>The Access-Control-Allow-Credentials header works in conjunction with the <strong><code>XMLHttpRequest.withCredentials</code></strong> property or with the <strong><code>credentials</code></strong> option in the Request() constructor of the <strong><code>Fetch API</code></strong>. Credentials must be set on both sides (the Access-Control-Allow-Credentials header and in the XHR or Fetch request) in order for the CORS request with credentials to succeed.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Access-Control-Allow-Credentials: true
</code></pre></div><h3 id="access-control-allow-methods-response">#Access-Control-Allow-Methods [Response]</h3>
<p>响应头指定访问资源以响应预检请求时允许的方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Access-Control-Allow-Methods: &lt;method&gt;, &lt;method&gt;, ...
</code></pre></div><h3 id="access-control-allow-headers-response">#Access-Control-Allow-Headers [Response]</h3>
<p>（预检请求）用于指明在实际请求中可以使用哪些HTTP头。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Access-Control-Allow-Headers: &lt;header-name&gt;, &lt;header-name&gt;, ...
</code></pre></div><h3 id="content-type-responserequest">#Content-Type [Response/Request]</h3>
<p>用于表明资源是哪种格式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Content-Type: text/html; charset<span style="color:#f92672">=</span>utf-8
Content-Type: multipart/form-data; boundary<span style="color:#f92672">=</span>something
</code></pre></div><h2 id="http-methods">HTTP Methods</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>使用场景</th>
<th>请求是否有body</th>
<th>响应是否有body</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取指定资源</td>
<td>获取网页，查询资源</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>POST</td>
<td>发送数据给服务端</td>
<td>新建资源；用户通过表单登录</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>PUT</td>
<td>新建资源或者替换指定资源</td>
<td>更新一条记录</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除指定资源</td>
<td>删除一条记录；</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>用于描述特定资源的访问选项</td>
<td>获取服务端支持的请求方法</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>CONNECT</td>
<td>开启双向通信</td>
<td>undefined</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>HEAD</td>
<td>描述</td>
<td>使用场景</td>
<td>没有</td>
<td>没有</td>
</tr>
<tr>
<td>PATCH</td>
<td>对资源部分更改</td>
<td>使用场景</td>
<td>有</td>
<td>没有</td>
</tr>
<tr>
<td>TRACE</td>
<td>描述</td>
<td>使用场景</td>
<td>有</td>
<td>有</td>
</tr>
</tbody>
</table>
<h3 id="get和post区别">#GET和POST区别</h3>
<p>被人熟知的区别有以下几点：</p>
<blockquote>
<ul>
<li>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</li>
<li>GET能被缓存，POST大部分不缓存。</li>
<li>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</li>
<li>GET对数据长度有限制，当发送数据时，GET方法向URL添加数据；URL 的长度是受限制的（URL的最大长度是2048个字符。POST无限制。</li>
<li>GET只允许ASCII字符。POST没有限制。也允许二进制数据。</li>
<li>与 POST 相比，GET的安全性较差，因为所发送的数据是URL的一部分。</li>
</ul>
</blockquote>
<p>上述是从表象来说两者有什么区别，那么从方法语义呢？<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/">HTTP协议中GET和POST的区别</a>好吧，其实就是说：GET请求对于资源不应该产生影响，POST	请求会造成资源变化，且多次请求变化不固定（非幂等）。</p>
<h3 id="put和post区别">#PUT和POST区别</h3>
<p>同一个PUT调用多次，不对产生其他影响，返回结果一致，资源变化一致。但是多次提交相同的POST可能会有不一样的响应，根据设计的不同，服务端可能提示：资源重复，或者新增相同的资源多次。也就是说PUT幂等，POST非幂等。</p>
<h2 id="总结">总结</h2>
<p>上述只能算HTTP协议的小部分知识，其包含及相关知识还有很多，如基本的HTTP鉴权，HTTPS的工作流程，HTTP如何基于TCP/IP协议来实现的。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5ac1eb2d6fb9a028de44dd41">来一场轰轰烈烈的HTTP协议扫盲</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP协议入门</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">互联网协议入门</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN HTTP Headers</a></li>
<li><a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/">HTTP协议中GET和POST的区别</a></li>
</ul>


                            
                            
                            
                            
                            
                        </section>

					</div>

                    

<footer id="footer">
    
    <section>
      <form method="post" action="post-action">
        <div class="fields">
          <div class="field">
            <label for="name">Name</label>
            <input type="text" name="name" id="name" />
          </div>
          <div class="field">
            <label for="email">Email</label>
            <input type="text" name="email" id="email" />
          </div>
          <div class="field">
            <label for="message">Message</label>
            <textarea name="message" id="message" rows="3"></textarea>
          </div>
        </div>
        <ul class="actions">
          <li><input type="submit" value='Send A Message' /></li>
        </ul>
      </form>
    </section>
    
    <section class="split contact">
        
        <section class="alt">
            <h3>Address</h3>
            <p>
                
                     Chengdu · China
                
                     <br/>  This is a city that comes and doesn&#39;t want to go
                
            </p>
        </section>
        
        
        <section>
            <h3>Phone</h3>
            <p><a href="tel:no%20way">no way</a></p>
        </section>
        
        
        <section>
            <h3>Email</h3>
            <p><a href="mailto:yeqown@gmail.com">yeqown@gmail.com</a></p>
        </section>
        
        
        <section>
            <h3>Social</h3>
            <ul class="icons alt">
                
                <li><a href="https://twitter.com/yeqown" class="icon alt fa-twitter"><span class="label">Twitter</span></a></li>
                
                
                
                
                
                <li><a href="https://github.com/yeqown" class="icon alt fa-github"><span class="label">GitHub</span></a></li>
                
                
                
                
                
            </ul>
        </section>
        
    </section>
</footer>

                    
<div id="copyright">
    <ul><li>&copy; Yeqown</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li><li>Hugo Port: <a href="https://curtistimson.co.uk">curttimson</a></li></ul>
</div>


            </div>
            
            










<script src='/assets/js/bundle.js'></script>
	</body>
</html>
